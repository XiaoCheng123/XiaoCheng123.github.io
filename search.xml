<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[带有延时的promise，封装函数延时执行]]></title>
    <url>%2F2018%2F06%2F21%2F%E5%B8%A6%E6%9C%89%E5%BB%B6%E6%97%B6%E7%9A%84promise%EF%BC%8C%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0%E5%BB%B6%E6%97%B6%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334// 1) 调用方式new People(&apos;whr&apos;).sleep(3).eat(&apos;apple&apos;).sleep(5).eat(&apos;durian&apos;);// 2) 打印结果&apos;hello, whr&apos; -(等待3s)--&gt; &apos;whr eat apple&apos; -(等待5s)--&gt; &apos;whr eat durian&apos;// 3) 以下是代码实现class People &#123; constructor(name) &#123; this.name = name; this.sayHello(); this.queue = Promise.resolve(); &#125; sayHello() &#123; console.log(`hello, $&#123;this.name&#125;`); &#125; sleep(time) &#123; // 这里对queue进行动态改变 this.queue = this.queue.then(() =&gt; &#123; return new Promise(res =&gt; &#123; setTimeout(() =&gt; &#123; res(); &#125;, time * 1000) &#125;) &#125;) return this; &#125; eat(food) &#123; this.queue = this.queue.then(() =&gt; &#123; console.log(`$&#123;this.name&#125; eat $&#123;food&#125;`); &#125;) return this; &#125;&#125;]]></content>
      <categories>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Function里面的aguments]]></title>
    <url>%2F2018%2F06%2F21%2FFunction%E9%87%8C%E9%9D%A2%E7%9A%84aguments%2F</url>
    <content type="text"><![CDATA[前言1.在JS里Array是一个类 slice是此类里的一个方法 ，那么使用此方法应该Array.prototype.slice这么去用slice从字面上的意思很容易理解就是截取（当然你不是英肓的话） 这方法如何使用呢? slice() 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。且原始数组不会被修改。1234567891011121314151617181920var animals = [&apos;ant&apos;, &apos;bison&apos;, &apos;camel&apos;, &apos;duck&apos;, &apos;elephant&apos;];console.log(animals.slice(2));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]console.log(animals.slice(2, 4));// expected output: Array [&quot;camel&quot;, &quot;duck&quot;]console.log(animals.slice(1, 5));// expected output: Array [&quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;]/* 用法 */arr.slice();// [0, end]arr.slice(begin);// [begin, end]arr.slice(begin, end);// [begin, end) slice 方法可以用来将一个类数组（Array-like）对象/集合转换成一个新数组。你只需将该方法绑定到这个对象上。 一个函数中的 arguments 就是一个类数组对象的例子。12345function list() &#123; return Array.prototype.slice.call(arguments);&#125;var list1 = list(1, 2, 3); // [1, 2, 3] arrayObj.slice(start, [end]) 很显然是截取数组的一部分。 123456function test(a,b,c,d) &#123; var arg = Array.prototype.slice.call(arguments,1); alert(arg); &#125; test(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;); //b,c,d 解释先给个例子，这是jqFloat插件里的代码： 1234567if (element.data(&apos;jDefined&apos;)) &#123; if (options &amp;&amp; typeof options === &apos;object&apos;) &#123; methods.update.apply(this, Array.prototype.slice.call(arguments, 1)); &#125;&#125; else &#123; methods.init.apply(this, Array.prototype.slice.call(arguments, 1));&#125; 因为arguments并不是真正的数组对象，只是与数组类似而已，所以它并没有slice这个方法，而Array.prototype.slice.call(arguments, 1)可以理解成是让arguments转换成一个数组对象，让arguments具有slice()方法。要是直接写arguments.slice(1)会报错。 原理Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组，除了IE下的节点集合（因为ie下的dom对象是以com对象的形式实现的，js对象与com对象不能进行转换） 1234567891011121314var a=&#123;length:2,0:&apos;first&apos;,1:&apos;second&apos;&#125;;//类数组,有length属性，长度为2，第0个是first，第1个是secondconsole.log(Array.prototype.slice.call(a,0));// [&quot;first&quot;, &quot;second&quot;],调用数组的slice(0);var a=&#123;length:2,0:&apos;first&apos;,1:&apos;second&apos;&#125;;console.log(Array.prototype.slice.call(a,1));//[&quot;second&quot;]，调用数组的slice(1);var a=&#123;0:&apos;first&apos;,1:&apos;second&apos;&#125;;//去掉length属性，返回一个空数组console.log(Array.prototype.slice.call(a,0));//[]function test()&#123; console.log(Array.prototype.slice.call(arguments,0));//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]，slice(0) console.log(Array.prototype.slice.call(arguments,1));//[&quot;b&quot;, &quot;c&quot;],slice(1)&#125;test(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习网站]]></title>
    <url>%2F2018%2F06%2F08%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[用 MDN 查 JavaScript 和 CSS 基础知识 用 Caniuse 查浏览器兼容性 用 jsfeeds 获取前端最新资讯（英文） 用 github 查询代码最新变化 用 HackerNews 获取编程最新资讯 去 v2ex 水技术 在 开发者头条 学习新的知识 当然，还有 segmentfault 我的文章都是写在这里的 div.io 不得不说，这里的发现里面有很多平时可以学习的demo hexo搭建个人博客 node学习网址 node中文网 git中文官网]]></content>
      <categories>
        <category>前端资源</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js的Event Loop机制解析]]></title>
    <url>%2F2018%2F06%2F08%2Fjs%E7%9A%84Event-Loop%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"></content>
      <categories>
        <category>前端资源</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2018%2F06%2F07%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[git 常用命令1234567891011121314151617181920212223242526272829303132初始化新版本库：git init全局设置：git config --global user.name &quot;xzavier&quot; git config --global user.email &quot;xzavier.xxx.com&quot;克隆版本库：git clone &quot;url&quot;查看分支：git branch创建分支：git branch branch_name切换分支：git checkout branch_name创建+切换分支：git checkout -b branch_name合并某分支到当前分支：git merge branch_name重命名分支：git branch -m branch_name branch_new_name //不会覆盖已经存在的分支重命名分支：git branch -M branch_name branch_new_name //会覆盖已经存在的分支删除分支：git branch -d branch_name 强制删除分支： git branch -D branch_name删除远程分支： git push origin : branch_name 拉取代码：git pull origin branch_name查看更改：git status 查看更改细节： git diff file_name查看谁修改过代码： git blame filename回到上次修改： git reset --hard添加单个文件：git add filename.js 添加所有js文件：git add *.js添加所有文件：git add .提交添加的文件：git commit -m &quot;your description about this branch&quot;提交单个文件：git commit -m &quot;your description about it&quot; filename.jspush分支：git push origin your_branch_name备份当前分支内容：git stash //在后面再讲讲这个查看历史记录：git log创建标签：git tag 1.0.0 //标签无法重命名显示标签列表：git tag 切出标签：git checkout 1.0.0删除标签：git tag -d 1.0.0查看git远程网址：git remote -v更改git远程网址：git remote set-url origin https://github.com/USERNAME/OTHERREPOSITORY.git]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[核心（1）Events]]></title>
    <url>%2F2018%2F05%2F28%2F%E6%A0%B8%E5%BF%83%EF%BC%881%EF%BC%89Events%2F</url>
    <content type="text"><![CDATA[简介Events API是node的最主要的核心，node的events类似DOM事件的Event事件。node主要通过一个类EventEmitter来进行模拟实现 EventEmitterEventEmitter提供了不少方法，但是最主要的是两个方法on和emit，其中我们如果使用过1234var http = require(&apos;http&apos;)var net = requere(&apos;net&apos;)var server = http.createServer(...) 就明白，其实http和net也是继承了EventEmitter的实例方法 on方法接受两个参数，监听事件名称，及事件触发调用的函数 123server.on(&apos;eventName&apos;, function()&#123; // 执行相应的操作&#125;) emit方法主要是针对某个对象进行触发事件，接受多个参数即事件名，第一个参数为事件名，另外的为参数 1server.emit(&apos;eventName&apos;) 具体实现]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合式继承]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[利用Object.create(prototype) 123456789101112131415161718192021function Parent(name) &#123; this.name = name;&#125;Parent.prototype.play = function() &#123; console.log(this.name);&#125;function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = Object.create(Parent.prototype);// 多态Child.prototype.play = function() &#123; Parent.prototype.play.call(this); console.log(this.age);&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[核心（2）Http]]></title>
    <url>%2F2018%2F05%2F28%2F%E6%A0%B8%E5%BF%83%EF%BC%882%EF%BC%89Http%2F</url>
    <content type="text"><![CDATA[简介http是node的核心不为过，毕竟node说实在，就是为了搭建服务器而使用的一门语言，具体还是得看看官网API 服务端实例简单一个实例吧1234567891011121314// 创建一个servervar http = require(&apos;http&apos;)var server = http.createServer()var handler = function(req, res) &#123; res.write(200, &#123;&#125;) res.end(&apos;hello world&apos;)&#125;// 对server的请求事件进行监听server.on(&apos;request&apos;, handler)// 将server运行在8080端口server.listen(8080) 客户端实例简单创建一个客户端 12345678910111213141516var http = require(&apos;http&apos;)var opts = &#123; host: &apos;127.0.0.1&apos;, port: &apos;8080&apos;, path: &apos;/&apos;, method: &apos;GET&apos;&#125;// 创建客户端实例var req = http.request(opts, function(res) &#123; console.log(res)&#125;)// 发送消息req.end()]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Global对象]]></title>
    <url>%2F2018%2F05%2F28%2FGlobal%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[所有属性都可以在程序的任何地方访问，即全局变量。在javascript中，通常window是全局对象，而node.js的全局对象是global，所有全局变量都是global对象的属性，如：console、process等。 全局对象 global：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如var x = 1等同于设置window.x = 1，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明var x = 1，该变量不是global对象的属性，global.x等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。 process：该对象表示Node所处的当前进程，允许开发者与该进程互动。 console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。 _filename：指向当前运行的脚本文件名。 _dirname：指向当前运行的脚本所在的目录。 除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。 全局函数 setTimeout()：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。 clearTimeout()：用于终止一个setTimeout方法新建的定时器。 setInterval()：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。 clearInterval()：终止一个用setInterval方法新建的定时器。 require()：用于加载模块。 Buffer()：用于操作二进制数据。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js体系结构]]></title>
    <url>%2F2018%2F05%2F28%2FNode-js%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Node架构Node.js主要分为四大部分，Node Standard Library，Node Bindings，V8，Libuv，架构图如下: Node Standard Library 是我们每天都在用的标准库，如Http, Buffer 模块。 Node Bindings 是沟通JS和C++的桥梁，封装V8和Libuv的细节，向上层提供基础API服务。这一层是支撑 Node.js 运行的关键，由 C/C++ 实现。 V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机。 Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I/O能力. C-ares：提供了异步处理 DNS 相关的能力。 http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力。 简单实例12345678910const http = require(&apos;http&apos;); // 加载node的http模块const hostname = &apos;127.0.0.1&apos;;const port = 1337;http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/plain&apos; &#125;); res.end(&apos;Hello World\n&apos;); // 创建成功结束返回的数据&#125;).listen(port, hostname, () =&gt; &#123; console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`);&#125;); 首先了解一下HTTP Server的继承关系，有利于更好的理解代码 最后一句1console.log(`Server running at http://$&#123;hostname&#125;:$&#123;port&#125;/`); 但却没有通过 require 获取，这就要说到global对象了，Node.js的顶层对象]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[v-model详解]]></title>
    <url>%2F2018%2F05%2F24%2Fv-model%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[v-model基础给组件添加 v-model 属性时，默认会把 value 作为组件的属性，然后把 ‘input’ 值作为给组件绑定事件时的事件名 123456789101112131415161718192021222324252627&lt;div id=&quot;demo&quot;&gt; &lt;currency-input v-model=&quot;price&quot;&gt;&lt;/currentcy-input&gt; &lt;span&gt;&#123;&#123;price&#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.bootcss.com/vue/2.3.0/vue.js&quot;&gt;&lt;/script&gt;&lt;script&gt;Vue.component(&apos;currency-input&apos;, &#123; template: ` &lt;span&gt; &lt;input ref=&quot;input&quot; :value=&quot;value&quot; &lt;!--为什么这里把 &apos;input&apos; 作为触发事件的事件名？`input` 在哪定义的？--&gt; @input=&quot;$emit(&apos;input&apos;, $event.target.value)&quot; &gt; &lt;/span&gt; `, props: [&apos;value&apos;],// 为什么这里要用 value 属性，value在哪里定义的？貌似没找到啊？&#125;)var demo = new Vue(&#123; el: &apos;#demo&apos;, data: &#123; price: 100, &#125;&#125;)&lt;/script&gt; 1234&lt;currency-input v-model=&quot;price&quot;&gt;&lt;/currentcy-input&gt;&lt;!--上行代码是下行的语法糖 &lt;currency-input :value=&quot;price&quot; @input=&quot;price = arguments[0]&quot;&gt;&lt;/currency-input&gt;--&gt; v-model 的缺点和解决办法1&lt;input type=&quot;checkbox&quot; v-model=&quot;sth&quot; /&gt; v-model 给我们提供好了 value 属性和 oninput 事件，但是，我们需要的不是 value 属性，而是 checked 属性，并且当你点击这个单选框的时候不会触发 oninput 事件，它只会触发 onchange 事件。这就尴尬 因为 v-model 只是用到了 input 元素上，所以这种情况好解决：↓ 1&lt;input type=&quot;checkbox&quot; :checked=&quot;status&quot; @change=&quot;status = $event.target.checked&quot; /&gt; 当 v-model 用到组件上时：↓12345678910&lt;my-checkbox v-model=&quot;foo&quot;&gt;&lt;/my-checkbox&gt;Vue.component(&apos;my-checkbox&apos;, &#123; tempalte: `&lt;input type=&quot;checkbox&quot; @change=&quot;$emit(&apos;input&apos;, $event.target.checked)&quot; :checked=&quot;value&quot; /&gt;` props: [&apos;value&apos;],&#125;) 在 Vue 2.2 版本，你可以在定义组件时通过 model 选项的方式来定制 prop/event：↓123456789101112131415&lt;my-checkbox v-model=&quot;foo&quot;&gt;&lt;/my-checkbox&gt;Vue.component(&apos;my-checkbox&apos;, &#123; tempalte: `&lt;input type=&quot;checkbox&quot; &lt;!--这里就不用 input 了，而是 balabala--&gt; @change=&quot;$emit(&apos;balabala&apos;, $event.target.checked)&quot; :checked=&quot;checked&quot; /&gt;` props: [&apos;checked&apos;], //这里就不用 value 了，而是 checked model: &#123; prop: &apos;checked&apos;, event: &apos;balabala&apos; &#125;,&#125;)]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise详解]]></title>
    <url>%2F2018%2F05%2F24%2FPromise%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[定义Promise是一个构造函数，构造参数为一个函数 构造成功后，函数立即执行；其中回调的异步操作加入异步队列，例如 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log(&apos;Promise&apos;); resolve();&#125;);promise.then(function() &#123; console.log(&apos;resolved.&apos;);&#125;);console.log(&apos;Hi!&apos;);// Promise// Hi!// resolved 在构造参数这个函数里面，若没有return，所有语句都执行 Promise.prototype的thenPromise函数有三种状态，pending变为resolved和从pending变为rejected then函数接受两个参数，第二个参数可选，例如 1234567var promise = new Promise(function()&#123; // do something() // resolved or rejected&#125;)// 这里的resloved和rejected都是函数，而且rejected可不填promise.then(resloved, rejected) then的链式调用then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 12345getJSON(&quot;/posts.json&quot;).then(function(json) &#123; return new Promise(...);&#125;).then(function(post) &#123; // ...&#125;); Promise.prototype的catchPromise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 12345678getJSON(&quot;/posts.json&quot;).then(function(json) &#123; return new Promise(...);&#125;).then(function(post) &#123; // ...&#125;).catch(function(err)&#123; // 处理上面两个promise返回的错误信息&#125;); Promise.all()和Promise.race()Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 1234const p = Promise.all([p1, p2, p3]);// p1，p2，p3都返回resolved，p才可以resolvedp.then(resolved,rejected) Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 1234const p = Promise.race([p1, p2, p3]);// p1，p2，p3哪个先改变状态，p就是什么状态p.then(resolved,rejected)]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6的Proxy和Reflect]]></title>
    <url>%2F2018%2F05%2F24%2FES6%E7%9A%84Proxy%E5%92%8CReflect%2F</url>
    <content type="text"><![CDATA[Proxy Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy就是一种代理，外界对该对象的访问，必须经过它，可以对外界的访问进行过滤和改写。 1234567891011121314151617var obj = new Proxy(&#123;&#125;, &#123; get: function (target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function (target, key, value, receiver) &#123; console.log(`setting $&#123;key&#125;!`); return Reflect.set(target, key, value, receiver); &#125;&#125;);obj.count = 1// setting count!++obj.count// getting count!// setting count!// 2 上面的代码里面，new Proxy()返回了一个{}，这个{}里面属性的set和get已经被重写。 Proxy构造函数 12// target为目标对象，handler为对对象的代理var proxy = new Proxy(target, handler); Proxy的get1234567891011121314151617var person = &#123; name: &quot;张三&quot;&#125;;var proxy = new Proxy(person, &#123; // get接受两个参数，一个是目标对象，一个是访问的属性 get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError(&quot;Property \&quot;&quot; + property + &quot;\&quot; does not exist.&quot;); &#125; &#125;&#125;);proxy.name // &quot;张三&quot;proxy.age // 抛出一个错误 Proxy的setset方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。1234567891011121314151617181920212223let validator = &#123; set: function(obj, prop, value) &#123; if (prop === &apos;age&apos;) &#123; if (!Number.isInteger(value)) &#123; throw new TypeError(&apos;The age is not an integer&apos;); &#125; if (value &gt; 200) &#123; throw new RangeError(&apos;The age seems invalid&apos;); &#125; &#125; // 对于满足条件的 age 属性以及其他属性，直接保存 obj[prop] = value; &#125;&#125;;let person = new Proxy(&#123;&#125;, validator);person.age = 100;person.age // 100person.age = &apos;young&apos; // 报错person.age = 300 // 报错 Reflect Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 Reflect对象一共有 13 个静态方法。 Reflect.apply(target, thisArg, args)Reflect.construct(target, args)Reflect.get(target, name, receiver)Reflect.set(target, name, value, receiver)Reflect.defineProperty(target, name, desc)Reflect.deleteProperty(target, name)Reflect.has(target, name)Reflect.ownKeys(target)Reflect.isExtensible(target)Reflect.preventExtensions(target)Reflect.getOwnPropertyDescriptor(target, name)Reflect.getPrototypeOf(target)Reflect.setPrototypeOf(target, prototype)上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。 两者的应用Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 123456789Proxy(target, &#123; set: function(target, name, value, receiver) &#123; var success = Reflect.set(target,name, value, receiver); if (success) &#123; log(&apos;property &apos; + name + &apos; on &apos; + target + &apos; set to &apos; + value); &#125; return success; &#125;&#125;); 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。 1234567891011121314var loggedObj = new Proxy(obj, &#123; get(target, name) &#123; console.log(&apos;get&apos;, target, name); return Reflect.get(target, name); &#125;, deleteProperty(target, name) &#123; console.log(&apos;delete&apos; + name); return Reflect.deleteProperty(target, name); &#125;, has(target, name) &#123; console.log(&apos;has&apos; + name); return Reflect.has(target, name); &#125;&#125;); 上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用的性能优化手段]]></title>
    <url>%2F2018%2F05%2F23%2F%E5%B8%B8%E7%94%A8%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[DOM优化高效使用HTML标签描述：HTML是一门标记语言，使用合理的HTML标签前你必须了解其属性，比如Flow Elements，Metadata Elements ，Phrasing Elements。比较基础的就是得知道块级元素和内联元素、盒模型、SEO方面的知识。 减少对DOM的操作描述：对DOM操作的代价是高昂的，这在网页应用中的通常是一个性能瓶颈。 天生就慢。在《高性能JavaScript》中这么比喻：“把DOM看成一个岛屿，把JavaScript(ECMAScript)看成另一个岛屿，两者之间以一座收费桥连接”。所以每次访问DOM都会教一个过桥费，而访问的次数越多，交的费用也就越多。所以一般建议尽量减少过桥次数。 解决方法：修改和访问DOM元素会造成页面的Repaint和Reflow，循环对DOM操作更是罪恶的行为。所以请合理的使用JavaScript变量储存内容，考虑大量DOM元素中循环的性能开销，在循环结束时一次性写入。 减少对DOM元素的查询和修改，查询时可将其赋值给局部变量。 注：在IE中:hover会降低响应速度。 BOM优化js优化css优化把CSS资源引用放到HTML文件顶部这样浏览器可以优先下载CSS并尽快完成页面渲染 有效的使用css选择器CSS是用来渲染页面的，也是存在渲染效率的问题。CSS选择符是从右向左进行匹配的，这里对css选择符按照开销从小到大的顺序梳理一下： ID选择符 #box 类选择符 .box 标签 div 伪类和伪元素 a:hover 当页面被触发引起回流（reflow）的时候，低效的选择符依然会引发更高的开销，所以请避免低效。 Repaint 和 Reflow描述：Repaint(重绘)就是在一个元素的外观被改变，但没有改变布局(宽高)的情况下发生，如改变visibility、outline、背景色等等。 Reflow(重排)就是DOM的变化影响到了元素的几何属性（宽和高），浏览器会重新计算元素的几何属性，会使渲染树中受到影响的部分失效，浏览器会验证DOM树上的所有其它结点的visibility属性，这也是Reflow低效的原因。如：改变窗囗大小、改变文字大小、内容的改变、浏览器窗口变化，style属性的改变等等。如果Reflow的过于频繁，CPU使用率就会噌噌的往上涨，所以前端也就有必要知道 Repaint 和 Reflow的知识。 解决方法：上面提到通过设置style属性改变结点样式的话，每设置一次都会导致一次reflow，所以最好通过设置class的方式； 有动画效果的元素，它的position属性应当设为fixed或absolute，这样不会影响其它元素的布局；如果功能需求上不能设置position为fixed或absolute，那么就权衡速度的平滑性。 总之，因为 Reflow 有时确实不可避免，所以只能尽可能限制Reflow的影响范围。 网络优化减少HTTP请求基本原理描述：在浏览器(客户端)和服务器发生通信时，就已经消耗了大量的时间，尤其是在网络情况比较糟糕的时候，这个问题尤其的突出。 一个正常HTTP请求的流程简述：如在浏览器中输入”www.xxxxxx.com&quot;并按下回车，浏览器再与这个URL指向的服务器建立连接，然后浏览器才能向服务器发送请求信息，服务器在接受到请求的信息后再返回相应的信息，浏览器接收到来自服务器的应答信息后，对这些数据解释执行。 解决方法：合并图片（css sprites），合并CSS和JS文件；图片较多的页面也可以使用 lazyLoad等技术进行优化。 使用CDN加速描述：”其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。” 使用可缓存的AJAX对于内容相同的请求，有时候没必要每次都从服务器拉取，合理的使用ajax缓存能加快ajax响应速度并减少服务器的压力 123456$.ajax(&#123; url : url, dataType : &quot;json&quot;, cache: true, success: function(data)&#123; // to do something... &#125;&#125;); 使用get请求POST请求会首先发送文件头，然后发送HTTP正文的数据。而使用GET只发送头部，所以在拉取数据时使用GET请求效率更高 其他优化JSON格式来进行数据交换描述：JSON是一种轻量级的数据交换格式，采用完全独立于语言的文本格式，是理想的数据交换格式。同时，JSON是 JavaScript原生格式，这意味着在 JavaScript 中处理 JSON数据不需要任何特殊的 API 或工具包。 与XML序列化相比，JSON序列化后产生的数据一般要比XML序列化后数据体积小，所以在Facebook等知名网站中都采用了JSON作为数据交换方式。 图片压缩注意控制Cookie大小和污染描述：因为Cookie是本地的磁盘文件，每次浏览器都会去读取相应的Cookie，所以建议去除不必要的Coockie，使Coockie体积尽量小以减少对用户响应的影响；使用Cookie跨域操作时注意在适应级别的域名上设置coockie以便使子域名不受其影响；Cookie是有生命周期的，所以请注意设置合理的过期时间，合理地Expire时间和不要过早去清除coockie，都会改善用户的响应时间。]]></content>
      <categories>
        <category>前端性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[防sql注入]]></title>
    <url>%2F2018%2F05%2F23%2F%E9%98%B2sql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[Web安全简史在Web1.0时代，人们更多是关注服务器端动态脚本语言的安全问题，比如将一个可执行脚本（俗称Webshell）通过脚本语言的漏洞上传到服务器上，从而获得服务器权限。 在Web发展初期，随着动态脚本语言的发展和普及，以及早期工程师对安全问题认知不足导致很多”安全血案”的发生，至今仍然遗留下许多历史问题，比如PHP语言至今仍然无法从语言本身杜绝「文件包含漏洞」），只能依靠工程师良好的代码规范和安全意识。伴随着Web2.0、社交网络、微博等一系列新型互联网产品的兴起，基于Web环境的互联网应用越来越广泛，Web攻击的手段也越来越多样，Web安全史上的一个重要里程碑是大约1999年发现的SQL注入攻击，之后的XSS，CSRF等攻击手段愈发强大，Web攻击的思路也从服务端转向了客户端，转向了浏览器和用户。 在安全领域，一般用帽子的颜色来比喻黑客的善与恶，白帽子是指那些工作在反黑客领域的技术专家，这个群体是”善”的的象征；而黑帽子则是指那些利用黑客技术造成破坏甚至谋取私利造成犯罪的群体，他们是”恶”的代表。“白帽子”和”黑帽子”是两个完全对立的群体。对于黑帽子而言，他们只要找到系统的一个切入点就可以达到入侵破坏的目的，而白帽子必须将自己系统所有可能被突破的地方都设防，以保证系统的安全运行。 这看起来好像是不公平的，但是安全世界里的规则就是这样，可能我们的网站1000处都布防的很好，考虑的很周到，但是只要有一个地方疏忽了，攻击者就会利用这个点进行突破，让我们另外的1000处努力白费。常见攻击方式一般说来，在Web安全领域，常见的攻击方式大概有以下几种：1、SQL注入攻击2、跨站脚本攻击 - XSS3、跨站伪造请求攻击 - CSRF4、文件上传漏洞攻击5、分布式拒绝服务攻击 - DDOS限于篇幅，本篇只讨论SQL注入攻击的技巧与防范。SQL注入常见攻击技巧SQL注入攻击是Web安全史上的一个重要里程碑，它从1999年首次进入人们的视线，至今已经有十几年的历史了，虽然我们现在已经有了很全面的防范对策，但是它的威力仍然不容小觑，SQL注入攻击至今仍然是Web安全领域中的一个重要组成部分。以PHP+MySQL为例，让我们以一个Web网站中最基本的用户系统来做实例演示，看看SQL注入究竟是怎么发生的。 1、创建一个名为demo的数据库：1CREATE DATABASE `demo` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 2、创建一个名为user的数据表，并插入1条演示数据：123456CREATE TABLE `demo`.`user` (`uid` INT( 11 ) NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT &apos;用户uid&apos;,`username` VARCHAR( 20 ) NOT NULL COMMENT &apos;用户名&apos;,`password` VARCHAR( 32 ) NOT NULL COMMENT &apos;用户密码&apos;) ENGINE = INNODB;INSERT INTO `demo`.`user` (`uid`, `username`, `password`) VALUES (&apos;1&apos;, &apos;plhwin&apos;, MD5(&apos;123456&apos;)); 实例一通过传入username参数，在页面打印出这个会员的详细信息，编写 userinfo.php 程序代码：1234567891011121314151617181920212223&lt;?phpheader(&apos;Content-type:text/html; charset=UTF-8&apos;);$username = isset($_GET[&apos;username&apos;]) ? $_GET[&apos;username&apos;] : &apos;&apos;;$userinfo = array();if($username)&#123; //使用mysqli驱动连接demo数据库 $mysqli = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &apos;demo&apos;); $sql = &quot;SELECT uid,username FROM user WHERE username=&apos;&#123;$username&#125;&apos;&quot;; //mysqli multi_query 支持执行多条MySQL语句 $query = $mysqli-&gt;multi_query($sql); if($query)&#123; do &#123; $result = $mysqli-&gt;store_result(); while($row = $result-&gt;fetch_assoc())&#123; $userinfo[] = $row; &#125; if(!$mysqli-&gt;more_results())&#123; break; &#125; &#125; while ($mysqli-&gt;next_result()); &#125;&#125;echo &apos;&lt;pre&gt;&apos;,print_r($userinfo, 1),&apos;&lt;/pre&gt;&apos;; 上面这个程序要实现的功能是根据浏览器传入的用户名参数，在页面上打印出这个用户的详细信息，程序写的这么复杂是因为我采用了mysqli的驱动，以便能使用到 multi_query 方法来支持同时执行多条SQL语句，这样能更好的说明SQL注入攻击的危害性。假设我们可以通过 http://localhost/test/userinfo.php?username=plhwin 这个URL来访问到具体某个会员的详情，正常情况下，如果浏览器里传入的username是合法的，那么SQL语句会执行：1SELECT uid,username FROM user WHERE username=&apos;plhwin&apos; 但是，如果用户在浏览器里把传入的username参数变为 plhwin’;SHOW TABLES– hack，也就是当URL变为 http://localhost/test/userinfo.php?username=plhwin&#39;;SHOW TABLES– hack 的时候，此时我们程序实际执行的SQL语句变成了： 1SELECT uid,username FROM user WHERE username=&apos;plhwin&apos;;SHOW TABLES-- hack&apos; 注意：在MySQL中，最后连续的两个减号表示忽略此SQL减号后面的语句，我本机的MySQL版本号为5.6.12，目前几乎所有SQL注入实例都是直接采用两个减号结尾，但是实际测试，这个版本号的MySQL要求两个减号后面必须要有空格才能正常注入，而浏览器是会自动删除掉URL尾部空格的，所以我们的注入会在两个减号后面统一添加任意一个字符或单词，本篇文章的SQL注入实例统一以 – hack 结尾。经过上面的SQL注入后，原本想要执行查询会员详情的SQL语句，此时还额外执行了 SHOW TABLES; 语句，这显然不是开发者的本意，此时可以在浏览器里看到页面的输出： 123456789101112Array( [0] =&gt; Array ( [uid] =&gt; 1 [username] =&gt; plhwin ) [1] =&gt; Array ( [Tables_in_demo] =&gt; user )) 你能清晰的看到，除了会员的信息，数据库表的名字user也被打印在了页面上，如果作恶的黑客此时将参数换成 plhwin’;DROP TABLE user– hack，那将产生灾难性的严重结果，当你在浏览器中执行 http://localhost/test/userinfo.php?username=plhwin&#39;;DROP TABLE user– hack 这个URL后，你会发现整个 user 数据表都消失不见了。通过上面的例子，大家已经认识到SQL注入攻击的危害性，但是仍然会有人心存疑问，MySQL默认驱动的mysql_query方法现在已经不支持多条语句同时执行了，大部分开发者怎么可能像上面的演示程序那样又麻烦又不安全。是的，在PHP程序中，MySQL是不允许在一个mysql_query中使用分号执行多SQL语句的，这使得很多开发者都认为MySQL本身就不允许多语句执行了，但实际上MySQL早在4.1版本就允许多语句执行，通过PHP的源代码，我们发现其实只是PHP语言自身限制了这种用法，具体情况大家可以看看这篇文章「PHP+MySQL多语句执行」。实例二如果系统不允许同时执行多条SQL语句，那么SQL注入攻击是不是就不再这么可怕呢？答案是否定的，我们仍然以上面的user数据表，用Web网站中常用的会员登录系统来做另外一个场景实例，编写程序login.php，代码如下：1234567891011121314151617181920212223242526272829303132&lt;?phpif($_POST)&#123; $link = mysql_connect(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;); mysql_select_db(&apos;demo&apos;, $link); $username = empty($_POST[&apos;username&apos;]) ? &apos;&apos; : $_POST[&apos;username&apos;]; $password = empty($_POST[&apos;password&apos;]) ? &apos;&apos; : $_POST[&apos;password&apos;]; $md5password = md5($password); $sql = &quot;SELECT uid,username FROM user WHERE username=&apos;&#123;$username&#125;&apos; AND password=&apos;&#123;$md5password&#125;&apos;&quot;; $query = mysql_query($sql, $link); $userinfo = mysql_fetch_array($query, MYSQL_ASSOC); if(!empty($userinfo))&#123; //登录成功，打印出会员信息 echo &apos;&lt;pre&gt;&apos;,print_r($userinfo, 1),&apos;&lt;/pre&gt;&apos;; &#125; else &#123; echo &quot;用户名不存在或密码错误！&quot;; &#125;&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Web登录系统SQL注入实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form name=&quot;LOGIN_FORM&quot; method=&quot;post&quot; action=&quot;&quot;&gt; 登录帐号: &lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; size=30 /&gt;&lt;br /&gt;&lt;br /&gt; 登录密码: &lt;input type=&quot;text&quot; name=&quot;password&quot; value=&quot;&quot; size=30 /&gt;&lt;br /&gt;&lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot; /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 此时如果输入正确的用户名 plhwin 和密码 123456，执行的SQL语句为：1SELECT uid,username FROM user WHERE username=&apos;plhwin&apos; AND password=&apos;e10adc3949ba59abbe56e057f20f883e&apos; 上面语句没有任何问题，可以看到页面打印出了登录成功后的会员信息，但如果有捣蛋鬼输入的用户名为 plhwin’ AND 1=1– hack，密码随意输入，比如 aaaaaa，那么拼接之后的SQL查询语句就变成了如下内容：1SELECT uid,username FROM user WHERE username=&apos;plhwin&apos; AND 1=1-- hack&apos; AND password=&apos;0b4e7a0e5fe84ad35fb5f95b9ceeac79&apos; 执行上面的SQL语句，因为 1=1 是永远成立的条件，这意味着黑客只需要知道别人的会员名，无需知道密码就能顺利登录到系统。如何确定SQL注入漏洞通过以上的实例，我们仍然还会有疑问：黑客并不知道我们程序代码的逻辑和SQL语句的写法，他是如何确定一个网站是否存在SQL注入漏洞呢？一般说来有以下2种途径：1、错误提示如果目标Web网站开启了错误显示，攻击者就可以通过反复调整发送的参数、查看页面打印的错误信息，推测出Web网站使用的数据库和开发语言等重要信息。2、盲注除非运维人员疏忽，否则大部分的Web运营网站应该都关闭了错误提示信息，此时攻击者一般会采用盲注的技巧来进行反复的尝试判断。 仍然以上面的数据表user为例，我们之前的查看会员详情页面的url地址为 userinfo.php?username=plhwin，此时黑客分别访问 userinfo.php?username=plhwin’ AND 1=1– hack 和 userinfo.php?username=plhwin’ AND 1=2– hack，如果前者访问能返回正常的信息而后者不能，就基本可以判断此网站存在SQL注入漏洞，因为后者的 1=2 这个表达式永远不成立，所以即使username传入了正确的参数也无法通过，由此可以推断这个页面存在SQL注入漏洞，并且可以通过username参数进行注入。如何防御SQL注入对于服务器配置层面的防范，应该保证生产环境的Webserver是关闭错误信息的，比如PHP在生产环境的配置文件php.ini中的display_errors应该设置为Off，这样就关闭了错误提示，下面我们更多的从编码的角度来看看如何防范SQL注入。 上面用两个实例分析了SQL注入攻击的技巧，可以看到，但凡有SQL注入漏洞的程序，都是因为程序要接受来自客户端用户输入的变量或URL传递的参数，并且这个变量或参数是组成SQL语句的一部分，对于用户输入的内容或传递的参数，我们应该要时刻保持警惕，这是安全领域里的「外部数据不可信任」的原则，纵观Web安全领域的各种攻击方式，大多数都是因为开发者违反了这个原则而导致的，所以自然能想到的，就是从变量的检测、过滤、验证下手，确保变量是开发者所预想的 1、检查变量数据类型和格式如果你的SQL语句是类似where id={$id}这种形式，数据库里所有的id都是数字，那么就应该在SQL被执行前，检查确保变量id是int类型；如果是接受邮箱，那就应该检查并严格确保变量一定是邮箱的格式，其他的类型比如日期、时间等也是一个道理。总结起来：只要是有固定格式的变量，在SQL语句执行前，应该严格按照固定格式去检查，确保变量是我们预想的格式，这样很大程度上可以避免SQL注入攻击。比如，我们前面接受username参数例子中，我们的产品设计应该是在用户注册的一开始，就有一个用户名的规则，比如5-20个字符，只能由大小写字母、数字以及一些安全的符号组成，不包含特殊字符。 此时我们应该有一个check_username的函数来进行统一的检查。不过，仍然有很多例外情况并不能应用到这一准则，比如文章发布系统，评论系统等必须要允许用户提交任意字符串的场景，这就需要采用过滤等其他方案了。2、过滤特殊符号对于无法确定固定格式的变量，一定要进行特殊符号过滤或转义处理。以PHP为例，通常是采用addslashes函数，它会在指定的预定义字符前添加反斜杠转义，这些预定义的字符是：单引号 (‘) 双引号 (“) 反斜杠 () NULL。来看2条SQL语句：123$uid = isset($_GET[&apos;uid&apos;]) ? $_GET[&apos;uid&apos;] : 0;$uid = addslashes(uid);$sql = &quot;SELECT uid,username FROM user WHERE uid=&apos;&#123;$uid&#125;&apos;&quot;; 以及123$uid = isset($_GET[&apos;uid&apos;]) ? $_GET[&apos;uid&apos;] : 0;$uid = addslashes(uid);$sql = &quot;SELECT uid,username FROM user WHERE uid=&#123;$uid&#125;&quot;; 上面两个查询语句都经过了php的addslashes函数过滤转义，但在安全性上却大不相同，在MySQL中，对于int类型字段的条件查询，上面个语句的查询效果完全一样，由于第一句SQL的变量被单引号包含起来，SQL注入的时候，黑客面临的首要问题是必须要先闭合前面的单引号，这样才能使后面的语句作为SQL执行，并且还要注释掉原SQL语句中的后面的单引号，这样才可以成功注入，由于代码里使用了addslashes函数，黑客的攻击会无从下手，但第二句没有用引号包含变量，那黑客也不用考虑去闭合、注释，所以即便同样采用addslashes转义，也还是存在SQL攻击漏洞。对于PHP程序+MySQL构架的程序，在动态的SQL语句中，使用单引号把变量包含起来配合addslashes函数是应对SQL注入攻击的有效手段，但这做的还不够，像上面的2条SQL语句，根据「检查数据类型」的原则，uid都应该经过intval函数格式为int型，这样不仅能有效避免第二条语句的SQL注入漏洞，还能使得程序看起来更自然，尤其是在NoSQL(如MongoDB)中，变量类型一定要与字段类型相匹配才可以。 从上面可以看出，第二个SQL语句是有漏洞的，不过由于使用了addslashes函数，你会发现黑客的攻击语句也存在不能使用特殊符号的条件限制，类似where username=’plhwin’这样的攻击语句是没法执行的，但是黑客可以将字符串转为16进制编码数据或使用char函数进行转化，同样能达到相同的目的，如果对这部分内容感兴趣，可以点击这里查看。而且由于SQL保留关键字，如「HAVING」、「ORDER BY」的存在，即使是基于黑白名单的过滤方法仍然会有或多或少问题，那么是否还有其他方法来防御SQL注入呢？3、绑定变量，使用预编译语句MySQL的mysqli驱动提供了预编译语句的支持，不同的程序语言，都分别有使用预编译语句的方法，我们这里仍然以PHP为例，编写userinfo2.php代码：12345678910111213141516171819202122&lt;?phpheader(&apos;Content-type:text/html; charset=UTF-8&apos;);$username = isset($_GET[&apos;username&apos;]) ? $_GET[&apos;username&apos;] : &apos;&apos;;$userinfo = array();if($username)&#123; //使用mysqli驱动连接demo数据库 $mysqli = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &apos;demo&apos;); //使用问号替代变量位置 $sql = &quot;SELECT uid,username FROM user WHERE username=?&quot;; $stmt = $mysqli-&gt;prepare($sql); //绑定变量 $stmt-&gt;bind_param(&quot;s&quot;, $username); $stmt-&gt;execute(); $stmt-&gt;bind_result($uid, $username); while ($stmt-&gt;fetch()) &#123; $row = array(); $row[&apos;uid&apos;] = $uid; $row[&apos;username&apos;] = $username; $userinfo[] = $row; &#125;&#125;echo &apos;&lt;pre&gt;&apos;,print_r($userinfo, 1),&apos;&lt;/pre&gt;&apos;; 从上面的代码可以看到，我们程序里并没有使用addslashes函数，但是浏览器里运行 http://localhost/test/userinfo2.php?username=plhwin&#39; AND 1=1– hack 里得不到任何结果，说明SQL漏洞在这个程序里并不存在。实际上，绑定变量使用预编译语句是预防SQL注入的最佳方式，使用预编译的SQL语句语义不会发生改变，在SQL语句中，变量用问号?表示，黑客即使本事再大，也无法改变SQL语句的结构，像上面例子中，username变量传递的 plhwin’ AND 1=1– hack 参数，也只会当作username字符串来解释查询，从根本上杜绝了SQL注入攻击的发生。]]></content>
      <categories>
        <category>前端安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回流和重绘]]></title>
    <url>%2F2018%2F05%2F17%2F%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98%2F</url>
    <content type="text"><![CDATA[1234567891011回流必将引起重绘，而重绘不一定会引起回流。当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：1、添加或者删除可见的DOM元素；2、元素位置改变；3、元素尺寸改变——边距、填充、边框、宽度和高度4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；5、页面渲染初始化；6、浏览器窗口尺寸改变——resize事件发生时；]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存泄漏]]></title>
    <url>%2F2018%2F05%2F10%2F%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[前言在说明内存泄漏之前，先说明一下为什么会有内存泄漏吧，那就是js垃圾回收机制 js的垃圾回收机制概述JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。 引用计数 IE 6, 7 对DOM对象进行引用计数回收 这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。 工作原理：跟踪记录每个值被引用的次数。 工作流程： 声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。 同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1. 当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1. 当引用次数变成0时，说明没办法访问这个值了 当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。 标记清楚 到2008年为止，IE,Firefox,Opera,Chrome和Safari的javascript实现使用的都是标记清除式的垃圾收集策略 工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。 工作流程： 垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。 去掉环境中的变量以及被环境中的变量引用的变量的标记。 再被加上标记的会被视为准备删除的变量。 垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。 常见的内存泄漏和解决办法 意外的全局变量引起的内存泄漏。 原因：全局变量，不会被回收。 解决：使用严格模式避免。 闭包引起的内存泄漏 原因：闭包可以维持函数内局部变量，使其得不到释放。 解决：将事件处理函数定义在外部，解除闭包,或者在定义事件处理函数的外部函数中，删除对dom的引用。 没有清理的DOM元素引用 原因：虽然别的地方删除了，但是对象中还存在对dom的引用 解决：手动删除。 被遗忘的定时器或者回调 原因：定时器中有dom的引用，即使dom删除了，但是定时器还在，所以内存中还是有这个dom。 解决：手动删除定时器和dom。 子元素存在引用引起的内存泄漏 原因：div中的ul li 得到这个div，会间接引用某个得到的li，那么此时因为div间接引用li，即使li被清空，也还是在内存中，并且只要li不被删除，他的父元素都不会被删除。 解决：手动删除清空。 总结内存泄漏就只是对于内存分配的不恰当的使用，在使用的时候注意是否会回收就好了]]></content>
      <categories>
        <category>前端安全</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC]]></title>
    <url>%2F2018%2F05%2F08%2FBFC%2F</url>
    <content type="text"><![CDATA[BFC概念具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 BFC触发条件 body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) BFC示例同一个 BFC 下外边距会发生折叠123456789101112&lt;head&gt;div&#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。 首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 1234567891011121314151617&lt;style&gt;.container &#123; overflow: hidden;&#125;p &#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/style&gt;&lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;container&quot;&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; BFC 可以包含浮动的元素（清除浮动）我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子 123&lt;div style=&quot;border: 1px solid #000;&quot;&gt; &lt;div style=&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;/div&gt;&lt;/div&gt; 由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。 123&lt;div style=&quot;border: 1px solid #000;overflow: hidden&quot;&gt; &lt;div style=&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;/div&gt;&lt;/div&gt; BFC 可以阻止元素被浮动元素覆盖123&lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div style=&quot;width: 200px; height: 200px;background: #eee&quot;&gt;我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;&lt;/div&gt; 这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden，就会变成：]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习日记（四）——Vue状态管理vuex]]></title>
    <url>%2F2018%2F02%2F02%2FVue%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94Vue%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86vuex%2F</url>
    <content type="text"><![CDATA[前言先说句前话，如果不是接触大型项目，不需要有多个子页面，不使用vuex也是完全可以的。 说实在话，我在阅读vuex文档的时候，也很难以去理解vuex，甚至觉得没有使用它我也可以。但是直到我在项目碰到下面这些问题： 当路由切换的时候，原本路由的数据太多，传递过去太麻烦。 有些数据是多个路由需要用到的，那我就需要从后台获取多次数据 当然，这些问题都可以解决，就是在实例化vue对象的时候，就将这些数据绑定在window对象上面。但是我们也不得不设想： 万一数据太多了，那么可阅读性是不是会下降 如果只是修改单独的数据，是不是所有的页面都可以更新 对于第一个问题，答案是肯定的，虽然说，我们现在也可以用模块化的思想去使可阅读性更加好，但是没有一个规范，对于刚入手项目的总是难以理解。 对于第二个问题，当你页面少的时候，是不会出现这样的问题的，但是如果页面多了，你就会发现，当你把window.$data里面的数据更新的时候，所有页面的计算属性都会失效，就是你无论怎么修改数据，页面都不会更新数据。 这时候，就需要用到我们的vuex了。 vuex介绍 那么vuex 到底是什么？ 引用官网的说法就是Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 是不是还是有点难以理解，其实简单的说vuex就是把这个项目的所有数据都存储在一个地方，方便修改和获取数据。 例如，我们从下面这张图给大家先简单的分析一下 在这张图片里面我们很明显可以看到三个部分 Vue Components 表示vue里面的组件 Backend API 后台API vuex 组件里面的数据管理 我们可以生动形象的理解，如果说Vuex是一个仓库，那么么Vue Components就就是售货者，负责把仓库里面的东西展现出来，Backend API就相当于入货的人，负责将货物买进来（也就是后台返回数据给前端，保存在vuex里面）。而vuex就是仓库，这个仓库里面有货物state，有管理货物进出的Muations 引用vuex在说state之前，我们可以先在我们vue项目引用vuex1npm install vuex 然后在我们的src目录下新建一个store的文件夹，在store文件夹里面新建一个index.js的文件1234567891011// ~/src/store/index.jsimport Vue from &apos;Vue&apos;import Vuex from &apos;Vuex&apos;// 在这里声明实例一个Vue 去引用Vuex状态管理插件// 这样就可以减少在main.js里面的代码量了Vue.use(Vuex)// 返回store实例对象export default new Vuex.Store(&#123;&#125;) 这里说一下吧，这里Store其实就是相当vuex实例化的一个仓库。 data替代者state 为什么说state是data的替代者呢？ 很容易理解，就是讲组件里面的局部参数，改成了一个可以全局使用的参数state，例如，我们在me.vue组件引用的数据todo。 那么我们可以在store里面这样实例化它出来12345678// ~/src/store/index.js// ...export default new Vuex.Store(&#123; state: &#123; todo: [] &#125;&#125;) 那么，我们在组件里面怎么使用这个数据呢？1234567891011// me.vue组件文件// ...&lt;script type=&quot;text/ecmascript-6&quot;&gt;export default &#123; data() &#123; meTodo: [] // 然后在方法里面引用this.meTodo = this.$store.state.todo &#125;&#125;&lt;/script&gt;// ... 是不是很简单，但是我们不可能每次使用这个值都要获取一次吧，这些vue团队也都想好了，我们可以通过计算属性来获取state里面的数据。12345678910111213// ...&lt;script type=&quot;text/ecmascript-6&quot;&gt;// 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from &apos;vuex&apos;export default &#123; computed: mapState([ // 映射 this.todo 为 store.state.todo &apos;todo&apos;])&#125;&lt;/script&gt;// ... 相当于1234567891011// ...&lt;script type=&quot;text/ecmascript-6&quot;&gt;export default &#123; computed: todo () &#123; return this.$store.state.todo &#125;])&#125;&lt;/script&gt;// ... 计算属性Getter有时候我们会需要对state的数据进行一些过滤操作，例如我们只要在todo里面大于10的数字，如果是用computed的话，我们就需要使用filter函数，为了更加简便，vuex也给我们提供了计算属性getter。 我们可以修改我们的~/src/store/index文件123456789// ...export default new Vuex.Store(&#123; state: &#123; todo: [] &#125;, getters: &#123; todo: state =&gt; state.todo.filter(number =&gt; number &gt; 10) &#125;&#125;) 然后在me.vue里面引用123456789101112131415// ...&lt;script type=&quot;text/ecmascript-6&quot;&gt;// 在单独构建的版本中辅助函数为 Vuex.mapGettersimport &#123; mapGetters &#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapGetters([ // 映射 this.todo 为 store.state.todo &apos;todo&apos; ]) &#125;&#125;&lt;/script&gt;// ... 这样就可以简单拿到大于10的todo数据了 修改state的Mutation 我们说了怎么获取数据，但是我们应该怎么修改数据呢，是不是直接赋值给数据就可以了呢？ 答案当然不是，vuex规定了，我们只能用Mutation来进行修改数据，那么，我们怎么进行修改数据呢？修改我们的~/src/store/index.js123456789101112// ...export default new Vuex.Store(&#123; state: &#123; todo: [] &#125;, getters: &#123; todo: state =&gt; state.todo.filter(number =&gt; number &gt; 10) &#125;, mutations: &#123; revsiseTode: (state, oneTodo) =&gt; (state.todo = oneTodo) // 修改state的值 &#125;&#125;) 然后在我们的me.vue组件里面修改123456789101112131415161718192021222324// ...// 在单独构建的版本中辅助函数为 Vuex.mapGettersimport &#123; mapGetters &#125; from &apos;vuex&apos;// 在单独构建的版本中辅助函数为 Vuex.mapMutationsimport &#123; mapMutations &#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapGetters([ // 映射 this.todo 为 store.state.todo &apos;todo&apos; ]) &#125;, method: &#123; ...mapMutations( [ // 将 `this.revsiseTode()` 映射为 `this.$store.commit(&apos;revsiseTode&apos;)` // 如果想传递参数可以使用this.$store.commit(&apos;revsiseTode&apos;, oneTode) // 或者Action &apos;revsiseTode&apos; ] ) &#125;&#125; Action的使用写了这么久，终于到了Action的出场了，其实不管怎么说，Action主要是为了与后台交互而使用的属性，这里，我就假设todo的数据在路由/me/gettodo里面能够获取，因此，修改~/store/index.js1234567891011121314151617// ...export default new Vuex.Store(&#123; state: &#123; todo: [] &#125;, getters: &#123; todo: state =&gt; state.todo.filter(number =&gt; number &gt; 10) &#125;, mutations: &#123; revsiseTode: (state, oneTodo) =&gt; (state.todo = oneTodo) // 修改state的值 &#125;, actions: &#123; getTodo: context =&gt; Vue.http.get(&apos;/me/gettodo&apos;, (res) =&gt; &#123; context.commit(&apos;revsiseTode&apos;, res.body.todo) &#125;) &#125;&#125;) 然后就可以通过触发我们的actions来提交mutations去修改state的数据了，在me.vue修改12345678910111213141516171819202122// ...// 在单独构建的版本中辅助函数为 Vuex.mapGettersimport &#123; mapGetters &#125; from &apos;vuex&apos;// 在单独构建的版本中辅助函数为 Vuex.mapMutationsimport &#123; mapActions &#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapGetters([ // 映射 this.todo 为 store.state.todo &apos;todo&apos; ]) &#125;, method: &#123; ...mapActions( [ &apos;reviseTodo&apos;, // 将 `this.reviseTodo()` 映射为 `this.$store.dispatch(&apos;reviseTodo&apos;) ] ) &#125;&#125;// ... vuex目录结构上面主要只是简单的讲了一下vuex的使用，也只是讲了一部分，不过相信看了这里之后再去官网就会有更深的理解。当然这些都是简单的使用，如果想把vuex运用到项目，必须把他们模块化更加好看，vuex官网也为我们提供了规范的项目目录结构，我这里就不多啰嗦几句了。 总结vuex其实不难，我一开始也以为很难一直学不会，只要多使用就会觉得，其实也就只是别人都封装好了的方法，我们去使用这个简便的仓库就行了。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习日记（二）——Vue核心思想]]></title>
    <url>%2F2018%2F02%2F01%2FVue%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94Vue%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[前言Vue.js是一个提供MVVM数据双向绑定的库，其核心思想无非就是： 数据驱动 组件系统 数据驱动Vue.js 的核心是一个响应的数据绑定系统，它让数据与DOM保持同步非常简单。在使用 jQuery 手工操作 DOM时，我们的代码常常是命令式的、重复的与易错的。Vue.js 拥抱数据驱动的视图概念。通俗地讲，它意味着我们在普通HTML模板中使用特殊的语法将 DOM “绑定”到底层数据。一旦创建了绑定，DOM将与数据保持同步。每当修改了数据，DOM 便相应地更新。这样我们应用中的逻辑就几乎都是直接修改数据了，不必与 DOM 更新搅在一起。这让我们的代码更容易撰写、理解与维护。 本人在阅读vue.js源码的时候，也发现了vue的数据驱动无非就是利用的是ES5Object.defineProperty和存储器属性，个人觉得也是vue比较轻便和灵活的原因之一。 getter和setter（所以只兼容IE9及以上版本），可称为基于依赖收集的观测机制。核心是VM，即ViewModel，保证数据和视图的一致性。 附：vue.js源码图在github上vue打包好的dist文件下面的vue.js可以找到（该图与核心技术无关，只是说明vue使用这个属性） 这个存储器属性也就是vue的核心，也是比jq好的地方之一，jq是通过绑定事件来进行操作dom，而vue和react是通过操作obj的属性来重新渲染dom 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 对入输入框input输入的内容都在output里面输出 --&gt; &lt;input type="text" id="input"&gt; &lt;br&gt; &lt;span id="output"&gt;&lt;/span&gt;&lt;/body&gt;&lt;script&gt; // 绑定事件的做法 // 但是没有办法从控制台控制信息修改value document.getElementById("input").addEventListener("keyup", function(e) &#123; document.getElementById("output").innerHTML = e.target.value &#125;) // 绑定虚拟dom的做法，就是通过改变一个obj的属性值 // 进而改变dom的值 var obj = &#123;&#125; // @obj 可以是任何一个对象 // @"string" 动态绑定的属性值 // @&#123;&#125; 构造getter和setter Object.defineProperty(obj, "string", &#123; get: function() &#123; console.log("getter") &#125;, set: function(val) &#123; document.getElementById("output").innerHTML = val document.getElementById("input").value = val &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 组件系统组件系统，就是由于vue有比较优秀的组件系统，所以，现在很多项目也都采用了vue框架，如果你想要深入的了解组件系统，建议可以看看vue的官方文档 用官方一点的话来形容，组件化就是：实现了扩展HTML元素，封装可用的代码。页面上每个独立的可视/可交互区域视为一个组件；每个组件对应一个工程目录，组件所需要的各种资源在这个目录下就近维护；页面不过是组件的容器，组件可以嵌套自由组合形成完整的页面。 简单的说，其实就是把页面进行分块处理，分成多个小块，每个小块就是一个组件，这样可以形成组件的复用，而且提高开发效率。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习日记（三）——Vue路由管理vue-router]]></title>
    <url>%2F2018%2F02%2F01%2FVue%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94Vue%E8%B7%AF%E7%94%B1%E7%AE%A1%E7%90%86vue-router%2F</url>
    <content type="text"><![CDATA[前言为了给读者更好的体验，去理解vue-router和下一篇介绍vuex，决定还是来一个实战教程来带大家更加的去深入理解vue-router，在这之前，读者先自行了解和去官网下载npm和node，附：npm官网 项目构建这里我采用vue-cli+webpack构建初始项目，在vue官网里面也有相关介绍，在这里我就手把手教大家一下吧，先通过控制台进入相关的文件目录下，然后输入 123456789101112# 后面是注释# $表示当前文件目录# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install# 运行项目my-preoject$ npm run dev npm install –global vue-cli 下载构建工具 vue init webpack my-project 初始化项目 npm install 下载相关资源到node_models npm run dev 运行项目后，在浏览器输入http://localhost:8080/#/可看到 介绍vue-router经过上面简单的构建之后，一个项目的初始化就完成了，这里vue-cli和webpack已经帮我们弄好了文件目录结构和基本目录 在进行使用vue-router之前，我不得不也先介绍一下vue-router是什么？ 它是一个vue.js下的路由组件，那什么是路由呢？网上有一大堆官方的介绍，相信对于小白是难以理解的，这里我就简单的说明一下吧。 其实路由也就是url，url是什么呢？url就是唯一资源定位符，简单的说，也就是标记页面的唯一存在的一个标签，就像https://www.baidu.com，这里的www.baidu.com就是唯一资源定位符，https就只是一种协议，规范计算机网络的通信协议。 介绍完这些，那么对于我们究竟该怎么用呢？ 其实很简单，在平时当中，我们就经常碰到在一个网站里面点击链接会弹到另外一个页面，然后就可以发现他们的url改变了，而vue-router就是这样，在同个域名下（这里的域名是http://localhost:8080），改变域名后面的字符参数，比如http://localhost:8080/me和http://localhost:8080/you是两个不同的页面就是靠vue-router进行实现的。 引用vue-router如果你在之前没有安装vue-router的话，建议可以先去官网，看着文档使用npm安装一下，这里就不多做介绍了。 首先我先在项目my-project/src/components（存放组件的目录）里面添加两个文件me.vue和you.vue123456789101112131415161718192021222324252627// me.vue&lt;template&gt; &lt;div&gt; 我是me &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/ecmascript-6&quot;&gt;export default &#123;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;// you.vue&lt;template&gt; &lt;div&gt; 我是you &lt;/div&gt;&lt;/template&gt;&lt;script type=&quot;text/ecmascript-6&quot;&gt;export default &#123;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 然后修改my-project/src/router（存放路由相关信息的目录）下面修改index.js成 12345678910111213141516171819202122232425262728293031import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import HelloWorld from &apos;@/components/HelloWorld&apos;// 导入组件import me from &apos;../components/me&apos;import you from &apos;../components/you&apos;Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: &apos;/&apos;, name: &apos;HelloWorld&apos;, component: HelloWorld &#125;, // 将组件命名到路由上，输入http://localhost:8080/#/me // 即可进入不同的页面 &#123; path: &apos;/me&apos;, component: me &#125;, // 将组件命名到路由上，输入http://localhost:8080/#/you // 即可进入不同的页面 &#123; path: &apos;/you&apos;, component: you &#125; ]&#125;) 这样只会输入http://localhost:8080/#/me就会进到其他页面，是不是很简单，那么我们怎么在页面里面进行跳转呢？ 这就运用到了更有趣的知识了就是router-link你只要在你的组件的代码下输入 1&lt;router-link :to=&quot;/me&quot;&gt;这里是跳转链接&lt;/router-link&gt; 网页就自动跳转到http://localhost:8080/#/me页面了，但是这样总是不好的，因为，如果由于一些原因，我们想修改路由的名字（比如me改成him）就得改两个文件的信息，因此，vue团队也早就想好了，就是name属性，将my-project/src/router（存放路由相关信息的目录）下面修改index.js成 1234567// ...&#123; path: &apos;/me&apos;, name: &apos;me&apos;, component: me&#125;,// ... 然后跳转就改成 1&lt;router-link :to=&quot;&#123; name: &apos;me&apos;&#125;&quot;&gt;这里是跳转链接&lt;/router-link&gt; 就可以进行跳转了 高级应用 前端路由 最初级的应用，就和上面的引用一样，当然还可以通过js代码来改变，这个也很简单，就是比如添加一个按钮，点击按钮通过js跳转到其他页面，就是重定向，简单的js代码也下面这样，就可以跳转到其他页面了 1vue.$router.push(&apos;/me&apos;) 动态路由 通过router-link传递参数，例如User，传入userId这个参数，进行渲染不同的路由信息 嵌套路由 嵌套路由其实简单的理解就是，子路由，例如，我想在me下面在添加几个路由him和she那上面的代码可以这样写之后输入http://localhost:8080/#/me/him就可以进入到子路由的页面 1234567891011121314151617// ... &#123; path: &apos;/me&apos;, name: &apos;me&apos;, component: me， children: [ &#123; path: &apos;him&apos; // ... &#125;, &#123; path: &apos;she&apos; // ... &#125; ] &#125;, // ... 懒加载 结合异步组件以及在组件的created钩子上触发获取数据的ajax请求，可以最大化的降低加载时间，减少流量消耗。这个对于没有项目的人可能接触比较少，建议先知道这个概念。 重定向 可以实现某些需要根据特定逻辑改变页面原本路由的需求，例如简单的未登录状态下的页面访问“个人信息”路由时应该重定向到登录路由页面。 History的控制 History是Html5的新语法，个人觉得就是对于跳转的时候，特别是微信小程序，就是控制点击回退按钮的时候不至于退出页面而跳转到自己想要的页面 总结其实还有很多高级应用场景，我就不一一列举出来了，因为这些其实最好还是上官方文档进行说明，我这里只是解释一下简单的用法，以及初学者可能对官方文档会有误解来进行说明一下，希望大家还是学会看API，附官网地址]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue学习日记（一）——Vue介绍]]></title>
    <url>%2F2018%2F01%2F31%2FVue%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94Vue%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[前言本人学习了一段时间的vue，并尝试写了一些小Demo之后，将vue投入了几个项目之后，一直在边学习边使用，经过看了vue,vuex,vue-router的官方文档和慕课网上的一些实战视频之后，深有体会，故此写下这些文章。 前端框架比较其实的话，前端有很多的框架，很多初学前端的人可能没有接触到框架，以为框架是很高大上的东西，就我个人而言，我是听从师姐的学习路线开始学习前端的，一开始的时候接触的就是html,css,js这些基本语言，对于框架，一直是觉得很高大上的东西。后来，经过长时间的与框架打交道之后，也明白了，基础对于前端开发者是很重要的，框架也就只是将你会复用的代码进行包装起来方便你的使用，最重要的还是基础。 目前前端开发有很多的框架在市面上，其实说是框架，如果从C语言java语言那些语言来说，也就是库，一些封装好的东西，告诉你用法，就可以简单的实现一个简单的项目了。如果想更加了解前端框架，建议可以百度百度，或者看这篇知乎讨论，点击里面的文章看看，引用一下这里的一张图片展示一下目前的前端框架。 是的这只是部分前端框架，就我个人觉得，目前前端框架的三大巨头也就只是vue,react,angular（顺序与排名无关）。 各个框架都有自己擅长的一方面： vue擅长单页面多路由的开发 react适合多页面，手机app还有一些大型的开发 angular系统比较完善，适合快速搭建产品的原型 但是也各有各的劣势： vue并不特别适合多页面的开发 react在单页面开发性能并不比vue好，因为vue比较轻便 angular不适合程序员去自我发挥很多，因为其基本配置好饿了很多东西 当然，以上也都只是个人的见解而已，有错误还望包涵指正，关于他们的社区，就不多做介绍了，三大框架社区都比较完善。 Vue的优势Vue.js是一个轻巧、高性能、可组件化的MVVM库，如果你不懂什么是mvvm模式可以看一下这篇文章个人觉得比较容易理解，同时拥有非常容易上手的API； Vue.js是一个构建数据驱动的Web界面的库。 Vue.js是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。 Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。 另一方面，Vue 完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。 简单的说，Vue.js是一个构建数据驱动的 web 界面的渐进式框架。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统 Vue.js的特性如下： 轻量级的框架 双向数据绑定 指令 插件化 Vue渐进式框架 为什么说vue是渐进式框架呢？ 其实vue的官方首页就说了，vue,渐进式JavaScript 框架 其实严格的说，vue并不是一个框架，他只是一个库，和jq一样，可以操作dom的库，不同的是vue操作的是虚拟dom，至于什么是虚拟dom我会在下篇文章继续介绍。 vue并不是框架，只是和他旁边的生态环境组成了一个框架，下面，贴一个官方的渐进式框架介绍图吧，方便理解。 正如上图解释，一个vue渐进式框架就是由 声明式渲染vue.js 组件系统element-ui（也可以用bootstrap等，但是建议还是用这个，因为其他的还要下载其他的dom库） 客户端路由vue-router 大型状态管理vuex 构建工具webpack Vue全家桶Vue著名的全家桶其实就是，包含了vue-router，vuex， vue-resource（现在基本不用，而是用更为简单的axios）。再加上构建工具vue-cli，就是一个完整的vue项目的核心构成。 同时，在vue调试方面，可以选择安装chrome插件vue Devtools，以及有专门的组件库elment-ui，轻轻松松就可以完成一个较大型的项目 总结vue个人觉得是很不错的框架，特别还是国内牛人发布的，接下来还会有vue一系列的文章，以及vue+axios+mysql+node+express全栈实现一个系统的文章，去更加深入的了解vue。当然还有更加深入的理解，大家也可以看看官方文档，都介绍的很充分了。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你需要了解的ES6的新特性（前沿技术）]]></title>
    <url>%2F2017%2F07%2F26%2F%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84ES6%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ES6新特性 最近在项目中遇到了很多ES6的语法，遇到了不少坑坑洼洼，因此，在这里就简单介绍一下ES6中的一些新特性 如果想真正的了解ES6和ES5有什么不同，这里推荐看一下阮一峰的一本《ECMAScript 6 入门》 在我下面，主要介绍一下ES6标准下的let, const, “=&gt;”, “…”的介绍和用法 ES6背景介绍ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 那么，ECMAScript 和 JavaScript 到底是什么关系？ 要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是1.0版 let命令基本用法ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。看到这里，是不是觉得let和C语言还有其他语言的语言很像了呢，确实，其实原理基本都差不多。 使用注意 不存在变量提升：var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 暂时性死区：只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 123456var tmp = 123;if (true) &#123; tmp = &apos;abc&apos;; // ReferenceError let tmp;&#125; 不允许重复声明：let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125; 快级作用域：这个特性是我觉得最奇怪的，原本javascript是作用域链的形式，为什么无缘无故要突然改变了自己之前的主意呢。不过这个也很容易理解，有过C语言和C++等语言基础的就会很了解快级作用域 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是10。 const命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 使用注意 仅仅保证地址不变const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。1234const a = [];a.push(&apos;Hello&apos;); // 可执行a.length = 0; // 可执行a = [&apos;Dave&apos;]; // 报错 箭头函数”=&gt;”基本用法ES6 允许使用“箭头”（=&gt;）定义函数123456var f = v =&gt; v;//等同于var f = function(v) &#123; return v;&#125;; 使用注意 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 这里说一下最重要的第一点吧12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log(&apos;id:&apos;, this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 数组拓展运算符”…”基本用法扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll(&apos;div&apos;)]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 也可以运用于函数及其他12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;var numbers = [4, 38];add(...numbers) // 42 文中就简单介绍这么多，想更加了解ES6新特性的可以自寻查看一下阮一峰的一本《ECMAScript 6 入门》]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack走在前端技术的前沿（深入浅出）]]></title>
    <url>%2F2017%2F07%2F25%2Fwebpack%E8%B5%B0%E5%9C%A8%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E7%9A%84%E5%89%8D%E6%B2%BF%EF%BC%88%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Webpack网上有很多webpack的介绍，也有不少的视频，但是不少人看到应该还是不是很了解webpack里面到底是讲什么，而且报错了之后也是不知所措 那么这里我作为一个工具小白就阐述一下小白面前应该怎么学习webpack吧，当你看完之后，我相信对其他工具也会有更深的了解 概述在我的文章里主要讲解： webpack基本介绍及安装 webpack基本配置和配置文件 webpack在项目中如何自动生成html文件 强大的loader加载器 还有更多的功能我也会在文中提及到 附：webpack官网地址[英文官网][中文官网] 1.webpack基本介绍及安装1.1 webpac基本介绍 Webpack是时下最流行的模块打包器 它的主要任务就是将各种格式的JavaScript代码，甚至是静态文件进行分析、压缩、合并、打包，最后生成浏览器支持的代码 用一张图片简单表示一下 特点： 代码拆分方案：webpack可以将应用代码拆分成多个块，每个块包含一个或多个模块，块可以按需异步加载，极大提升大规模单页应用的初始加载速度 智能的静态分析：webpack的智能解析器几乎可以处理任何第三方库 Loader加载器：webpack只能处理原生js模块，但是loader可以将各种资源转换为js模块 plugin插件：webpack有功能丰富的插件系统，满足各种开发需求 快速运行：webpack 使用异步 I/O 和多级缓存提高运行效率，使得它能够快速增量编译 综合来说webpack综合了目前网络上的打包工具的优点，但是也要合理使用，不然也会适得其反 1.2 webpack的安装 第一步，首先得安装好node.js和npm npm是前端开发者必备的下载工具吧，如果你连这个也没有安装的话，那么你就得快点安装了，这里附一个gulp打包工具的教程，这里第一和第二步有node.js和npm的安装具体教程，如果你没有安装，那就得快点入门了。 第二步，进入webpack世界 首先，新建一个webpack-test文件夹作为你的项目目录 然后，用npm初始化你的项目，进入cmd，切换到你的目录下，输入：1npm init 然后会出现一大堆输入的东西，这里我们全部选择默认输入enter就好了 输入完了之后，它会提示你输入的信息给你核对，按下确认之后，就会在你的项目目录下生成了package.json 下一步，我们在我们的文件夹里面安装一下webpack吧，在项目目录下的cmd输入1npm install webpack --save-dev 这就安装好了，这里就给大家来一个小Demo，让大家更加了解webpack的打包方式吧，如果已经有基础的同学可以跳过这里 1.3 webpack几个小Demo在webpack-test下新建一个hello.js，输入下面的代码1234//自定义一个函数function hello (str) &#123; alert(str);&#125; 然后在命令行输入1webpack hello.js hello.bundle.js 这里的意思是用webpack文件将hello.js打包成hello.bundle.js输出在根目录下，成功之后在根目录下就会出现hello.bundle.js文件 然后介绍一下我们打包成功的各个东西的含义吧 然后再在根目录下新建一个world.js，在文件里输入1234//随便自定义一个函数function world () &#123;&#125; 再去修改hello.js成为123456require(&apos;./world.js&apos;) //连接到另外一个函数块//自定义一个函数function hello (str) &#123; alert(str);&#125; 再输入一下1webpack hello.js hello.bundle.js 进行打包之后就会发现，打包成功里面hello.js的chunks序列号是0，world.js的chunks序列号是1，然后在hello.bundle.js看到他们的序列号也是这样。 那么如果我想也把css文件也打包进去应该怎么办呢？ 我们再在根目录下新建一个style.css，在里面简单输入1234html, body &#123; padding: 0; margin: 0;&#125; 然后这里我们需要下载两个loaders加载器，为什么要下载loaders加载器呢，你也可以想一想，css文件和js文件毕竟不一样，如果在hello.js引入style.css那么肯定会报错，这个时候，我们需要一种东西帮忙加载我们的css成js 接下来我们下载两个loaders加载器，后面说一下这两个的作用，在命令行输入1npm install css-loader style-loader 然后把hello.js改成1234567require(&apos;./world.js&apos;) //连接到另外一个函数块require(&apos;css-loader!./style.css&apos;) //利用css-loader加载器解析css文件使之可读//自定义一个函数function hello (str) &#123; alert(str);&#125; 再在输入一下指令，打包好了后了可以观察hello.bundle.js里面就多了css文件里面的内容 这时候，你也许会觉得，我说了那么多，那么，怎么把这些东西用到我们的页面中吗？下面就会说到 在我们的跟目录下新建一个index.html，加入下面内容123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;webpack&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./hello.bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 再把我们的style.css改成12345678html, body &#123; padding: 0; margin: 0;&#125;body &#123; color: red;&#125; 再把我们的hello.js改成12345678910require(&apos;./world.js&apos;) //连接到另外一个函数块require(&apos;style-loader!css-loader!./style.css&apos;)//利用css-loader加载器解析再用style-loader解析css文件使之可读//自定义一个函数function hello (str) &#123; alert(str);&#125;hello(&apos;hello webpack&apos;); 然后我们再打包运行一下,就可以在页面看到我们的结果，这时候如果你细心，就会发现我们在css-loader前面加了个style-loader，如果你不加的话，你就会发现你的页面打开后不是红色的，因为还没经过style-loader的解析，当然这只是一种方法，还有其他方法可以自寻在官网看看文档。 如果你觉得每次修改之后打包也很麻烦，这时候我们的watch就有作用了，你可以在打包后面加入，例如输入1webpack hello.js hello.bundle.js --watch 然后下次修改就不用在进行输入打包代码了，这上面也就是简单的介绍了一下我们的webpack是怎么从一个文件链接到很多文件的。 2.webpack基本配置和配置文件 这里就是我们最重要的一个部分了，如果你看过很多webpack打包后的开源项目之后，你就会发现，有些时候你不知道从哪里看起，那就从配置文件开始看起来吧 相信你应该也在不少的文章中看到有关于配置文件的说法的吧，毕竟配置文件也算是最重要的一部分了，这里也可以推荐你看一篇我觉得还不错的webpack入门 不过我如果你没有基础的话，建议继续看下我的再去看那一篇，收获会更大 首先，我们新建一个项目webpack-demo，按照我上面教程文章里面下载安装好webpack，安装完了之后，我们需要新建几个文件以及文件夹，如下面所示 然后在index.html输入12345678910&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;webpack demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&quot;./dist/js/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在webpack.config.js也就是webpack的配置文件里面输入12345678910// webpack.config.jsmodule.exports = &#123; entry:&apos;./src/script/main.js&apos;, //我们的入口文件，相当于前面一节webpack-test中的hello.js output:&#123; path: __dirname + &quot;/dist/js&quot;, /*打包完了之后，把内容输出到这个文件夹上,也可以写成&quot;./dist/js&quot;， 但是这样放在服务器上路径可能会出错，所以加上__dirname*/ filename: &apos;bundle.js&apos; //输入到上面path文件夹里面的bundle.js，没有则自动新建 &#125;&#125; 再在main.js里面输入123456//main.jsfunction helloworld () &#123; alert(&apos;hello world&apos;);&#125;helloworld(); 在命令行输入webpack,就将我们的入口文件及其链接文件（这里还没有）打包输出在dist/js目录下面的bundle.js文件了。 这就是我们的配置文件的最简单的用法，以后我们还可以在里面配置很多loaders，甚至更复杂的打包，下面一步步说明吧。 我们也可以不用在命令行里面输入webpack，因为我们可能以后会查询更多东西，因此我们可以，在package.json的script里面加入：1&quot;webpack&quot;:&quot;webpack --config webpack.config.js --progress --color&quot; 这里的–progress和–color只是为了输出进度条和color，没有实际意义，然后在命令行输入npm run webpack就可以默认使用webpack进行打包了。 还有更多关于我们入口文件和输出文件的介绍，我建议看一下慕课网的这个视频会更加了解webpack配置文件 3.webpack在项目中如何自动生成html文件 在说这个之前，我们为什么要自动生成html页面？我们直接用index.html不就可以了？但是实际项目往往是有多个页面的，不过这里我们就简单介绍一个页面怎么自动生成，多个也是同样的原理，我们先来安装一个插件html-webpack-plugin，我们在命令行输入：1npm install html-webpack-plugin --save-dev 然后把我们的webpack.config.js里面修改成1234567891011121314151617// webpack.config.jsvar htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;)//引入我们的插件module.exports = &#123; entry: &#123; main: &apos;./src/script/main.js&apos;, &#125;, //我们的入口文件，相当于前面一节webpack-test中的hello.js output:&#123; path: __dirname + &quot;/dist/js&quot;, /*打包完了之后，把内容输出到这个文件夹上,也可以写成&quot;./dist/js&quot;， 但是这样放在服务器上路径可能会出错，所以加上__dirname*/ filename: &apos;[name]-[hash].js&apos; //输入到上面path文件夹里面的bundle.js，没有则自动新建 &#125;, plugins:[ new htmlWebpackPlugin() //对插件进行实例化 ]&#125; 然后，在我们的dist下面就有了一个项目自动生成的inex.html文件了 但是如果你细心就可以发现这个时候的index.html和我们原来的index.html没有任何的联系，这时候我们需要修改我们配置文件中的插件实例化那里修改成12345plugins:[ new htmlWebpackPlugin(&#123; template: &apos;index.html&apos; &#125;) //对插件进行实例化] 再打包一次之后，就会发现生成的dist目录下面的index.html文件就会绑定了其他js文件。更具体的就请查看一下官方文档了，毕竟篇幅不能太长。 4.强大的loader加载器 前面我们也有所提到我们的loader加载器，但是实际中是怎么样的呢，这里我围绕我们项目经常利用babel-loader转换ES6 Loaders需要单独安装并且需要在webpack.config.js下的modules关键字下进行配置，Loaders的配置选项包括以下几方面： test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） 首先，新建一个工程webpack-loader吧，然后将项目用npm初始化后，再在项目下下载webpack，然后构建好下面的这些目录 用npm下载一下html-webpack-plugin插件1npm install html-webpack-plugin --save-dev 修改我们的index.html成123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; layer.html123&lt;div class=&quot;layer&quot;&gt; &lt;div&gt;this is a layer&lt;/div&gt;&lt;/div&gt; layer.js12345678910// import tpl from &apos;./layer.html&apos;function layer () &#123; return &#123; name: &apos;layer&apos;, tpl: tpl &#125;&#125;export default layer; app.js12345678910//app.jsimport layer from &apos;./component/layer/layer.js&apos;;//导入layer//使用ES6语法const App = function () &#123; console.log(layer);&#125;new App() 利用babel-loader转换ES6Babel其实是一个编译JavaScript的平台，它的强大之处表现在可以通过编译帮你达到以下目的： 下一代的JavaScript标准（ES6，ES7），这些标准目前并未被当前的浏览器完全的支持； 使用基于JavaScript进行了拓展的语言，比如React的JSX 首先，我们先安装Babel在命令行输入1npm install --save-dev babel-loader babel-core 再安装一下babel中的latest这里我们需要用到1npm install --save-dev babel-preset-latest 修改我们的配置文件webpack.config.js1234567891011121314151617181920212223242526272829var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: &#123; main: &apos;./src/app.js&apos;, &#125;, //我们的入口文件，相当于前面一节webpack-test中的hello.js output:&#123; path: __dirname + &quot;/dist/js&quot;, /*打包完了之后，把内容输出到这个文件夹上,也可以写成&quot;./dist/js&quot;， 但是这样放在服务器上路径可能会出错，所以加上__dirname*/ filename: &apos;bundle.js&apos; //输入到上面path文件夹里面的bundle.js，没有则自动新建 &#125;, module: &#123; loaders: [ &#123; test: /\.js$/, //匹配所有的js文件 loader: &apos;babel-loader&apos;, //引用lbabel插件 &#125; ] &#125;, plugins: [ new htmlWebpackPlugin(&#123; filename:&apos;index.html&apos;, template:&apos;index.html&apos;, inject:&apos;body&apos; //将script标签加载进body &#125;) ]&#125; 再在我们的package.json下加入1234567&#123; //... &quot;babel&quot;: &#123; &quot;presets&quot;: [&quot;latest&quot;] &#125;, //...&#125; 在命令行输入webpack，就可以在我们的dist目录下面的js里面看到我们的配置文件已经有了这些文件 其他加载器css,less,sass等的原理也是一样，这里就不一一介绍了 有兴趣的话，可以继续看看慕课网的视频，在下也是受人启发。 还有更多的加载器可以在我们的webpack官网进行查询，这里我就不进行多解释了]]></content>
      <categories>
        <category>打包构建工具</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白gulp开发——gulp安装，介绍及less自动编译成css篇]]></title>
    <url>%2F2017%2F03%2F15%2F%E5%B0%8F%E7%99%BDgulp%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94gulp%E5%AE%89%E8%A3%85%EF%BC%8C%E4%BB%8B%E7%BB%8D%E5%8F%8Aless%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E6%88%90css%E7%AF%87%2F</url>
    <content type="text"><![CDATA[小白gulp开发，哈哈，为什么说是小白呢，因为作者我本人也只会html,css,js其他任何框架，工具几乎后没怎么用过。但是现在前端趋向工程化了，再也不想以前一样一个文件夹文件夹的，而是逐渐有了打包，编译等等出现。因此也学习一下gulp开发。 说了那么多，那么，到底什么是gulp，以及怎么安装gulp呢？ 附：gulp介绍 安装gulp的过程，是不是感觉有些奇怪，node.js是什么，npm又是什么？ 本人简单的理解：ndoe.js就是JavaScript工具包，里面封装了很多与网络，I/O等相关方法，并提供了API借口查询。而npm就是一个运行在node.js上的一个软件下载管理，帮忙用来下载软件的。类似的，cnpm就是下载的时候不用翻墙。 安装配置好了gulp之后，那就说说怎么来进行把less编译成css文件 附：小demo教程。这个教程有基本怎么配置及运行，若读者想多点尝试，也可以把目录树进行修改，按照注释就可以创建自己的目录结构。]]></content>
      <categories>
        <category>打包构建工具</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度前端任务(3)(4)(5)——巧谈前端基础html,css布局]]></title>
    <url>%2F2017%2F01%2F13%2F%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E4%BB%BB%E5%8A%A1-3-4-5-%E2%80%94%E2%80%94%E5%B7%A7%E8%B0%88%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80html-css%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[经过了百度前端技术学院任务三和四五，在这里总结一下前端布局的一些个人见解，很多前端新手就是没有理解怎么布局而一直学不好 123456先说一下，我个人理解的前端布局的思想吧。在前端布局的时候，先不要设计太多什么margin,padding什么的首先，你要清楚的是，你要的布局是什么例如，我这里拿百度前端技术学院的任务(5)作为例子讲解一下吧 附：百度前端技术学院的任务(5) 首先，根据题意，我们很容易得知，这是由一个头尾和内容的布局，布局采用的是类似淘宝双飞翼布局做成的CSS实现右侧固定宽度，左侧宽度自适应（点击链接即可知道具体怎么实现） 不过这不是这一篇的重点，重点是上中下布局。怎么实现呢？这里附上html和css代码 123456&lt;!--首部--&gt;&lt;div id=&quot;top&quot;&gt;&lt;/div&gt;&lt;!--内容--&gt;&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;&lt;!--尾部--&gt;&lt;div id=&quot;footer&quot;&gt;&lt;/div&gt; 1234567891011121314#top&#123; height: 50px; background: black;&#125;#content&#123; height: 550px; background: gray;&#125;#footer&#123; height: 50px; background: blueviolet;&#125; 形成了上中下结构之后，再进行其他地方的编辑，注意，其他地方，一般要用class不要滥用id(虽然两者用起来都差不多)。接下来我，来示范一下CSS实现右侧固定宽度，左侧宽度自适应的做法吧。 附代码1234&lt;div id=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122#content&#123; height: 550px; width: 100%; background: gray;&#125;.left&#123; height: 500px; width: 100%; margin-left: -200px; float: left; background: yellow;&#125;.right&#123; position: absolute; top: 0; right: 0; height: 200px; width: 200px; background: red;&#125; 这样就用绝对布局实现了一个比较简单的右侧固定宽度，左侧宽度自适应的做法。 然后再在各个板块上加上各自的margin,padding属性就比较很好看了。 但是，可能有很多新手还不是很清楚margin,padding和width属性到底具体指什么，这里我用一张图说明一下吧。 具体如果还不知道怎么做，可以留言，我会细心帮你解答。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器默认样式及css初始化]]></title>
    <url>%2F2017%2F01%2F12%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F%E5%8F%8Acss%E5%88%9D%E5%A7%8B%E5%8C%96%2F</url>
    <content type="text"><![CDATA[为什么要初始化css? 建站老手都知道，这是为了考虑到浏览器的兼容问题，其实不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 相信很多人都曾经出现过多多少少的，有时候进行网页布局的时候，不知道为什么设置的网页边距总是达不到自己想要的效果。 比如，我在这个属性设置了60px，但是，它却变成了92px. 查看了一下所有属性，原来是浏览器默认加上去的。 再看看，为什么我，没加float之前是正常的。 加了float后变成不正常了,在这里，我也没有加margin属性。 原来，是加了float使其脱离了文档流 然后，浏览器默认加上了margin-top: 16px和margin-bottom: 16px;然后60+16+16=92; 当然，还有很多类似的问题，这里附上一些网站的默认css属性 http://www.iecss.com/ 那么，应该怎么样解决这个问题呢？ 可以在css加上1234*&#123; margin: 0; padding: 0;&#125; 有很多人也是这样写的。这确实很简单，但有人就会感到疑问：*号这样一个通用符在编写代码的时候是快，但如果网站很大，CSS样式表文件很大，这样写的话，他会把所有的标签都初始化一遍，这样就大大的加强了网站运行的负载，会使网站加载的时候需要很长一段时间。 还有就是把可能用上的属性值加上，这里引用了雅虎工程师提供的CSS初始化示例代码 123456789101112131415body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td &#123; margin:0; padding:0; &#125;body &#123; background:#fff; color:#555; font-size:14px; font-family: Verdana, Arial, Helvetica, sans-serif; &#125;td,th,caption &#123; font-size:14px; &#125;h1, h2, h3, h4, h5, h6 &#123; font-weight:normal; font-size:100%; &#125;address, caption, cite, code, dfn, em, strong, th, var &#123; font-style:normal; font-weight:normal;&#125;a &#123; color:#555; text-decoration:none; &#125;a:hover &#123; text-decoration:underline; &#125;img &#123; border:none; &#125;ol,ul,li &#123; list-style:none; &#125;input, textarea, select, button &#123; font:14px Verdana,Helvetica,Arial,sans-serif; &#125;table &#123; border-collapse:collapse; &#125;html &#123;overflow-y: scroll;&#125;.clearfix:after &#123;content: &quot;.&quot;; display: block; height:0; clear:both; visibility: hidden;&#125;.clearfix &#123; *zoom:1; &#125; 然后，每次写css之前都加上这个就不用担心什么问题了。]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发工具篇(3)——tortoiseGit的使用提交代码篇]]></title>
    <url>%2F2017%2F01%2F11%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%AF%87-3-%E2%80%94%E2%80%94tortoiseGit%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E7%AF%87%2F</url>
    <content type="text"><![CDATA[在前面的文章中，我们讲解过git和tortoise的安装，但是，在许多新手面前，git的使用还是一脸懵逼，那么就说一下怎么简单的使用tortoiseGit吧 由于使用git的方法很多，这里就讲一种我觉比较简单的一种吧，首先要配置好github的ssh，如果不知道怎么配置，可以参考前端开发工具篇(1)——安装git和乌龟tortoiseGit 接下来，说正题了 1.先右键一下桌面(或者其他文件夹),然后选择Git Createrre… 在弹出的对话框勾选make it bare 2.在工作目录下,先确认身份TortoiseGit–&gt;Setting,在打开的对话框里,左边选git,右边就会出现写用户名和邮箱的地方 ==注意核对用户名和邮箱== 在用户工作目录下点击右键,选择git clone,弹出对话框 点击ok后,发现此文件夹下多了一个隐藏的文件夹.git,则clone成功 3.ethan用户在.git同级目录下添加一个文件index.jsp,里面写内容”hello git!”然后右键Tortoisegit–&gt;add,完成后index.jsp变成+号然后右键Git Commit -&gt; “master”… 在弹出的对话框,输入message信息后点ok,此时index.jsp变成对勾,提交到了本地服务器然后右键Tortoisegit–&gt;push则提交到了远程服务器]]></content>
      <categories>
        <category>前端开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>tortoiseGit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发工具篇(2)——安装git和乌龟tortoiseGit]]></title>
    <url>%2F2017%2F01%2F10%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%AF%87(2)%E2%80%94%E2%80%94%E5%AE%89%E8%A3%85git%E5%92%8C%E4%B9%8C%E9%BE%9FtortoiseGit%2F</url>
    <content type="text"><![CDATA[作为一个前端开发人员，开发工具先是非常重要的，俗话说”欲力其工必先利其器” git是每个程序员必须要学会的技能，但是git命令输入比较还是比较繁琐，有桌面端肯定更好。 附：安装git和乌龟git教程 在安装tortoiseGit的时候可能会出现,2503,2502错误。 按照网上的说法是要进入cmd管理员身份,然后输入mriexec \package”路径”(例如mrexec \package”F:\text.msi”) 但是我在输入的时候发现提示另外的错误： “无法打开该修补程序包，请与应用供应商联系”… 这时候，发现了，mriexec应该是安装exe文件的，然后我在cmd(以管理员身份)直接打开msi文件就可以直接安装了(例如:F:\test.msi)。]]></content>
      <categories>
        <category>前端开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>tortoiseGit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发工具篇(1)——汇总篇]]></title>
    <url>%2F2017%2F01%2F10%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%AF%87(1)%E2%80%94%E2%80%94%E6%B1%87%E6%80%BB%E7%AF%87%2F</url>
    <content type="text"><![CDATA[作为一个前端开发人员，开发工具先是非常重要的，俗话说”欲力其工必先利其器 在这里主要介绍几个软件给大家: git(mygit)和tortoiseGit，强大的git工具。 vs code，前端开发的主要工具另外也有其他的(例如sublime等,这里就不一一介绍了)。 Node.js,这是一个Javascript运行环境(runtime),用于方便地搭建响应速度快、易于扩展的网络应用。 有道云笔记，一个用来记录的文件，写博客会用到 具体安装和下载见其他文章]]></content>
      <categories>
        <category>前端开发工具</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>vscode</tag>
        <tag>node.js</tag>
      </tags>
  </entry>
</search>
